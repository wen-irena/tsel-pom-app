import msfnz from"../common/msfnz";import tsfnz from"../common/tsfnz";import sign from"../common/sign";import adjust_lon from"../common/adjust_lon";import phi2z from"../common/phi2z";import{HALF_PI,EPSLN}from"../constants/values";export function init(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<EPSLN)){var t=this.b/this.a;this.e=Math.sqrt(1-t*t);var s=Math.sin(this.lat1),i=Math.cos(this.lat1),h=msfnz(this.e,s,i),a=tsfnz(this.e,this.lat1,s),n=Math.sin(this.lat2),o=Math.cos(this.lat2),r=msfnz(this.e,n,o),e=tsfnz(this.e,this.lat2,n),l=tsfnz(this.e,this.lat0,Math.sin(this.lat0));Math.abs(this.lat1-this.lat2)>EPSLN?this.ns=Math.log(h/r)/Math.log(a/e):this.ns=s,isNaN(this.ns)&&(this.ns=s),this.f0=h/(this.ns*Math.pow(a,this.ns)),this.rh=this.a*this.f0*Math.pow(l,this.ns),this.title||(this.title="Lambert Conformal Conic")}};export function forward(t){var s=t.x,i=t.y;Math.abs(2*Math.abs(i)-Math.PI)<=EPSLN&&(i=sign(i)*(HALF_PI-2*EPSLN));var h,a,n=Math.abs(Math.abs(i)-HALF_PI);if(n>EPSLN)h=tsfnz(this.e,i,Math.sin(i)),a=this.a*this.f0*Math.pow(h,this.ns);else{if((n=i*this.ns)<=0)return null;a=0}var o=this.ns*adjust_lon(s-this.long0);return t.x=this.k0*(a*Math.sin(o))+this.x0,t.y=this.k0*(this.rh-a*Math.cos(o))+this.y0,t};export function inverse(t){var s,i,h,a,n,o=(t.x-this.x0)/this.k0,r=this.rh-(t.y-this.y0)/this.k0;this.ns>0?(s=Math.sqrt(o*o+r*r),i=1):(s=-Math.sqrt(o*o+r*r),i=-1);var e=0;if(0!==s&&(e=Math.atan2(i*o,i*r)),0!==s||this.ns>0){if(i=1/this.ns,h=Math.pow(s/(this.a*this.f0),i),-9999===(a=phi2z(this.e,h)))return null}else a=-HALF_PI;return n=adjust_lon(e/this.ns+this.long0),t.x=n,t.y=a,t};export var names=["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_2SP","lcc"];export default{init:init,forward:forward,inverse:inverse,names:names};