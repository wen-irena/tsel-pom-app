import CustomElementInternals from"./CustomElementInternals.js";import DocumentConstructionObserver from"./DocumentConstructionObserver.js";import Deferred from"./Deferred.js";import*as Utilities from"./Utilities.js";export default class CustomElementRegistry{constructor(e){this._elementDefinitionIsRunning=!1,this._internals=e,this._whenDefinedDeferred=new Map,this._flushCallback=(e=>e()),this._flushPending=!1,this._pendingDefinitions=[],this._documentConstructionObserver=new DocumentConstructionObserver(e,document)}define(e,t){if(!(t instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!Utilities.isValidCustomElementName(e))throw new SyntaxError(`The element name '${e}' is not valid.`);if(this._internals.localNameToDefinition(e))throw new Error(`A custom element with name '${e}' has already been defined.`);if(this._elementDefinitionIsRunning)throw new Error("A custom element is already being defined.");let n,i,s,o,r;this._elementDefinitionIsRunning=!0;try{const e=t.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");function l(t){const n=e[t];if(void 0!==n&&!(n instanceof Function))throw new Error(`The '${t}' callback must be a function.`);return n}n=l("connectedCallback"),i=l("disconnectedCallback"),s=l("adoptedCallback"),o=l("attributeChangedCallback"),r=t.observedAttributes||[]}catch(e){return}finally{this._elementDefinitionIsRunning=!1}const a={localName:e,constructor:t,connectedCallback:n,disconnectedCallback:i,adoptedCallback:s,attributeChangedCallback:o,observedAttributes:r,constructionStack:[]};this._internals.setDefinition(e,a),this._pendingDefinitions.push(a),this._flushPending||(this._flushPending=!0,this._flushCallback(()=>this._flush()))}_flush(){if(!1===this._flushPending)return;this._flushPending=!1;const e=this._pendingDefinitions,t=[],n=new Map;for(let t=0;t<e.length;t++)n.set(e[t].localName,[]);this._internals.patchAndUpgradeTree(document,{upgrade:e=>{if(void 0!==e.__CE_state)return;const i=e.localName,s=n.get(i);s?s.push(e):this._internals.localNameToDefinition(i)&&t.push(e)}});for(let e=0;e<t.length;e++)this._internals.upgradeElement(t[e]);for(;e.length>0;){const t=e.shift(),i=t.localName,s=n.get(t.localName);for(let e=0;e<s.length;e++)this._internals.upgradeElement(s[e]);const o=this._whenDefinedDeferred.get(i);o&&o.resolve(void 0)}}get(e){const t=this._internals.localNameToDefinition(e);if(t)return t.constructor}whenDefined(e){if(!Utilities.isValidCustomElementName(e))return Promise.reject(new SyntaxError(`'${e}' is not a valid custom element name.`));const t=this._whenDefinedDeferred.get(e);if(t)return t.toPromise();const n=new Deferred;return this._whenDefinedDeferred.set(e,n),this._internals.localNameToDefinition(e)&&!this._pendingDefinitions.some(t=>t.localName===e)&&n.resolve(void 0),n.toPromise()}polyfillWrapFlushCallback(e){this._documentConstructionObserver.disconnect();const t=this._flushCallback;this._flushCallback=(n=>e(()=>t(n)))}};window.CustomElementRegistry=CustomElementRegistry,CustomElementRegistry.prototype.define=CustomElementRegistry.prototype.define,CustomElementRegistry.prototype.get=CustomElementRegistry.prototype.get,CustomElementRegistry.prototype.whenDefined=CustomElementRegistry.prototype.whenDefined,CustomElementRegistry.prototype.polyfillWrapFlushCallback=CustomElementRegistry.prototype.polyfillWrapFlushCallback;